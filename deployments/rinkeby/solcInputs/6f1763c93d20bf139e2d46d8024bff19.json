{
  "language": "Solidity",
  "sources": {
    "contracts/RocketJoeFactory.sol": {
      "content": "// SPDX-License-Identifier: None\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./interfaces/IRocketJoeFactory.sol\";\nimport \"./interfaces/IJoeFactory.sol\";\nimport \"./interfaces/IJoePair.sol\";\nimport \"./interfaces/ILaunchEvent.sol\";\nimport \"./interfaces/IRocketJoeToken.sol\";\n\n/// @title Rocket Joe Factory\n/// @author Trader Joe\n/// @notice Factory that creates Rocket Joe events\ncontract RocketJoeFactory is IRocketJoeFactory, Ownable {\n    address public override penaltyCollector;\n    address public override eventImplementation;\n\n    address public override rJoe;\n    uint256 public override rJoePerAvax;\n    address public override wavax;\n    address public override router;\n    address public override factory;\n\n    uint256 public override PHASE_ONE_DURATION = 2 days;\n    uint256 public override PHASE_ONE_NO_FEE_DURATION = 1 days;\n    uint256 public override PHASE_TWO_DURATION = 1 days;\n\n    mapping(address => address) public override getRJLaunchEvent;\n    mapping(address => bool) public override isRJLaunchEvent;\n    address[] public override allRJLaunchEvents;\n\n    /// @notice Creates the launch event factory\n    /// @dev Uses clone factory pattern to save space\n    /// @param _eventImplementation Implementation of launch event contract\n    /// @param _rJoe rJOE token address\n    /// @param _wavax WAVAX token address\n    /// @param _penaltyCollector Address that collects all withdrawal penalties\n    /// @param _router Router used to create LP on Trader Joe AMM\n    /// @param _factory Factory used to get info of JoePairs\n    constructor(\n        address _eventImplementation,\n        address _rJoe,\n        address _wavax,\n        address _penaltyCollector,\n        address _router,\n        address _factory\n    ) {\n        require(\n            _eventImplementation != address(0) &&\n                _rJoe != address(0) &&\n                _wavax != address(0) &&\n                _penaltyCollector != address(0) &&\n                _router != address(0) &&\n                _factory != address(0),\n            \"RJFactory: Addresses can't be null address\"\n        );\n        IRocketJoeToken(_rJoe).initialize();\n\n        eventImplementation = _eventImplementation;\n        rJoe = _rJoe;\n\n        wavax = _wavax;\n        penaltyCollector = _penaltyCollector;\n        router = _router;\n        factory = _factory;\n        rJoePerAvax = 100;\n    }\n\n    /// @notice Returns the number of launch events\n    /// @return The number of launch events ever created\n    function numLaunchEvents() external view override returns (uint256) {\n        return allRJLaunchEvents.length;\n    }\n\n    /// @notice Creates a launch event contract\n    /// @param _issuer Address of the project issuing tokens for auction\n    /// @param _phaseOneStartTime Timestamp of when launch event will start\n    /// @param _token Token that will be issued through this launch event\n    /// @param _tokenAmount Amount of tokens that will be issued\n    /// @param _tokenIncentivesPercent Additional tokens that will be given as\n    /// incentive for locking up LPs during phase 3 expressed as a percentage\n    /// of the issuing tokens for sale, scaled to 1e18\n    /// @param _floorPrice Price of each token in AVAX, scaled to 1e18\n    /// @param _maxWithdrawPenalty Maximum withdrawal penalty that can be met\n    /// during phase 1\n    /// @param _fixedWithdrawPenalty Withdrawal penalty during phase 2\n    /// @param _maxAllocation Maximum number of AVAX each participant can commit\n    /// @param _userTimelock Amount of time users' LPs will be locked for\n    /// during phase 3\n    /// @param _issuerTimelock Amount of time issuer's LP will be locked for\n    /// during phase 3\n    /// @return Address of launch event contract\n    function createRJLaunchEvent(\n        address _issuer,\n        uint256 _phaseOneStartTime,\n        address _token,\n        uint256 _tokenAmount,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external override returns (address) {\n        require(\n            getRJLaunchEvent[_token] == address(0),\n            \"RJFactory: token has already been issued\"\n        );\n        require(_issuer != address(0), \"RJFactory: issuer can't be 0 address\");\n        require(_token != address(0), \"RJFactory: token can't be 0 address\");\n        require(_token != wavax, \"RJFactory: token can't be wavax\");\n        require(\n            _tokenAmount > 0,\n            \"RJFactory: token amount needs to be greater than 0\"\n        );\n        require(\n            IJoeFactory(factory).getPair(_token, wavax) == address(0) ||\n                IJoePair(IJoeFactory(factory).getPair(_token, wavax))\n                    .totalSupply() ==\n                0,\n            \"RJFactory: liquid pair already exists\"\n        );\n\n        address launchEvent = Clones.clone(eventImplementation);\n\n        // msg.sender needs to approve RocketJoeFactory\n        IERC20(_token).transferFrom(msg.sender, launchEvent, _tokenAmount);\n\n        ILaunchEvent(payable(launchEvent)).initialize(\n            _issuer,\n            _phaseOneStartTime,\n            _token,\n            _tokenIncentivesPercent,\n            _floorPrice,\n            _maxWithdrawPenalty,\n            _fixedWithdrawPenalty,\n            _maxAllocation,\n            _userTimelock,\n            _issuerTimelock\n        );\n\n        getRJLaunchEvent[_token] = launchEvent;\n        isRJLaunchEvent[launchEvent] = true;\n        allRJLaunchEvents.push(launchEvent);\n\n        _emitLaunchedEvent(_issuer, _token, _phaseOneStartTime);\n\n        return launchEvent;\n    }\n\n    /// @notice Set rJOE address\n    /// @param _rJoe New rJOE address\n    function setRJoe(address _rJoe) external override onlyOwner {\n        IRocketJoeToken(_rJoe).initialize();\n        rJoe = _rJoe;\n        emit SetRJoe(_rJoe);\n    }\n\n    /// @notice Set address to collect withdrawal penalties\n    /// @param _penaltyCollector New penalty collector address\n    function setPenaltyCollector(address _penaltyCollector)\n        external\n        override\n        onlyOwner\n    {\n        penaltyCollector = _penaltyCollector;\n        emit SetPenaltyCollector(_penaltyCollector);\n    }\n\n    /// @notice Set JoeRouter address\n    /// @param _router New router address\n    function setRouter(address _router) external override onlyOwner {\n        router = _router;\n        emit SetRouter(_router);\n    }\n\n    /// @notice Set JoeFactory address\n    /// @param _factory New factory address\n    function setFactory(address _factory) external override onlyOwner {\n        factory = _factory;\n        emit SetFactory(_factory);\n    }\n\n    /// @notice Set amount of rJOE required to deposit 1 AVAX into launch event\n    /// @dev Configured by team between launch events to control inflation\n    function setRJoePerAvax(uint256 _rJoePerAvax) external override onlyOwner {\n        rJoePerAvax = _rJoePerAvax;\n        emit SetRJoePerAvax(_rJoePerAvax);\n    }\n\n    /// @notice Set duration of each of the three phases\n    /// @param _phaseNumber Can be only 1 or 2\n    /// @param _duration Duration of phase in seconds\n    function setPhaseDuration(uint256 _phaseNumber, uint256 _duration)\n        external\n        override\n        onlyOwner\n    {\n        if (_phaseNumber == 1) {\n            require(\n                _duration > PHASE_ONE_NO_FEE_DURATION,\n                \"RJFactory: phase one duration lower than no fee duration\"\n            );\n            PHASE_ONE_DURATION = _duration;\n        } else if (_phaseNumber == 2) {\n            PHASE_TWO_DURATION = _duration;\n        }\n    }\n\n    /// @notice Set the no fee duration of phase 1\n    /// @param _noFeeDuration Duration of no fee phase\n    function setPhaseOneNoFeeDuration(uint256 _noFeeDuration)\n        external\n        override\n        onlyOwner\n    {\n        require(\n            _noFeeDuration < PHASE_ONE_DURATION,\n            \"RJFactory: no fee duration bigger than phase one duration\"\n        );\n        PHASE_ONE_NO_FEE_DURATION = _noFeeDuration;\n    }\n\n    /// @dev This function emits an event after a new launch event has been created\n    /// It is only seperated out due to `createRJLaunchEvent` having too many local variables\n    function _emitLaunchedEvent(\n        address _issuer,\n        address _token,\n        uint256 _phaseOneStartTime\n    ) internal {\n        uint256 _phaseTwoStartTime = _phaseOneStartTime + PHASE_ONE_DURATION;\n        uint256 _phaseThreeStartTime = _phaseTwoStartTime + PHASE_TWO_DURATION;\n\n        emit RJLaunchEventCreated(\n            _issuer,\n            _token,\n            _phaseOneStartTime,\n            _phaseTwoStartTime,\n            _phaseThreeStartTime,\n            rJoe,\n            rJoePerAvax\n        );\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/interfaces/IRocketJoeFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.8.0;\n\ninterface IRocketJoeFactory {\n    event RJLaunchEventCreated(\n        address indexed issuer,\n        address indexed token,\n        uint256 phaseOneStartTime,\n        uint256 phaseTwoStartTime,\n        uint256 phaseThreeStartTime,\n        address rJoe,\n        uint256 rJoePerAvax\n    );\n    event SetRJoe(address indexed token);\n    event SetPenaltyCollector(address indexed collector);\n    event SetRouter(address indexed router);\n    event SetFactory(address indexed factory);\n    event SetRJoePerAvax(uint256 rJoePerAvax);\n\n    function eventImplementation() external view returns (address);\n\n    function penaltyCollector() external view returns (address);\n\n    function wavax() external view returns (address);\n\n    function rJoePerAvax() external view returns (uint256);\n\n    function router() external view returns (address);\n\n    function factory() external view returns (address);\n\n    function rJoe() external view returns (address);\n\n    function PHASE_ONE_DURATION() external view returns (uint256);\n\n    function PHASE_ONE_NO_FEE_DURATION() external view returns (uint256);\n\n    function PHASE_TWO_DURATION() external view returns (uint256);\n\n    function getRJLaunchEvent(address token)\n        external\n        view\n        returns (address launchEvent);\n\n    function isRJLaunchEvent(address token) external view returns (bool);\n\n    function allRJLaunchEvents(uint256) external view returns (address pair);\n\n    function numLaunchEvents() external view returns (uint256);\n\n    function createRJLaunchEvent(\n        address _issuer,\n        uint256 _phaseOneStartTime,\n        address _token,\n        uint256 _tokenAmount,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external returns (address pair);\n\n    function setPenaltyCollector(address) external;\n\n    function setRouter(address) external;\n\n    function setFactory(address) external;\n\n    function setRJoe(address) external;\n\n    function setRJoePerAvax(uint256) external;\n\n    function setPhaseDuration(uint256, uint256) external;\n\n    function setPhaseOneNoFeeDuration(uint256) external;\n}\n"
    },
    "contracts/interfaces/IJoeFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.8.0;\n\ninterface IJoeFactory {\n    event PairCreated(\n        address indexed token0,\n        address indexed token1,\n        address pair,\n        uint256\n    );\n\n    function feeTo() external view returns (address);\n\n    function feeToSetter() external view returns (address);\n\n    function migrator() external view returns (address);\n\n    function getPair(address tokenA, address tokenB)\n        external\n        view\n        returns (address pair);\n\n    function allPairs(uint256) external view returns (address pair);\n\n    function allPairsLength() external view returns (uint256);\n\n    function createPair(address tokenA, address tokenB)\n        external\n        returns (address pair);\n\n    function setFeeTo(address) external;\n\n    function setFeeToSetter(address) external;\n\n    function setMigrator(address) external;\n}\n"
    },
    "contracts/interfaces/IJoePair.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.8.0;\n\ninterface IJoePair {\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external pure returns (string memory);\n\n    function symbol() external pure returns (string memory);\n\n    function decimals() external pure returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    function nonces(address owner) external view returns (uint256);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n    event Burn(\n        address indexed sender,\n        uint256 amount0,\n        uint256 amount1,\n        address indexed to\n    );\n    event Swap(\n        address indexed sender,\n        uint256 amount0In,\n        uint256 amount1In,\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n    function factory() external view returns (address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 reserve0,\n            uint112 reserve1,\n            uint32 blockTimestampLast\n        );\n\n    function price0CumulativeLast() external view returns (uint256);\n\n    function price1CumulativeLast() external view returns (uint256);\n\n    function kLast() external view returns (uint256);\n\n    function mint(address to) external returns (uint256 liquidity);\n\n    function burn(address to)\n        external\n        returns (uint256 amount0, uint256 amount1);\n\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function skim(address to) external;\n\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "contracts/interfaces/ILaunchEvent.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"./IJoePair.sol\";\n\ninterface ILaunchEvent {\n    struct UserInfo {\n        uint256 allocation;\n        uint256 balance;\n        bool hasWithdrawnPair;\n        bool hasWithdrawnIncentives;\n    }\n\n    function initialize(\n        address _issuer,\n        uint256 _phaseOne,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external;\n\n    function auctionStart() external view returns (uint256);\n\n    function PHASE_ONE_DURATION() external view returns (uint256);\n\n    function PHASE_ONE_NO_FEE_DURATION() external view returns (uint256);\n\n    function PHASE_TWO_DURATION() external view returns (uint256);\n\n    function tokenIncentivesPercent() external view returns (uint256);\n\n    function floorPrice() external view returns (uint256);\n\n    function userTimelock() external view returns (uint256);\n\n    function issuerTimelock() external view returns (uint256);\n\n    function maxWithdrawPenalty() external view returns (uint256);\n\n    function fixedWithdrawPenalty() external view returns (uint256);\n\n    function rJoePerAvax() external view returns (uint256);\n\n    function getReserves() external view returns (uint256, uint256);\n\n    function token() external view returns (IERC20Metadata);\n\n    function pair() external view returns (IJoePair);\n\n    function getUserInfo(address) external view returns (UserInfo memory);\n}\n"
    },
    "contracts/interfaces/IRocketJoeToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IRocketJoeToken {\n    /**\n     * @dev Initialize variables.\n     *\n     * Needs to be called by RocketJoeFactory.\n     */\n    function initialize() external;\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Destroys `amount` tokens from `from`.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burnFrom(address from, uint256 amount) external;\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/LaunchEventLens.sol": {
      "content": "// SPDX-License-Identifier: None\n\npragma solidity ^0.8.0;\n\nimport \"./interfaces/ILaunchEvent.sol\";\nimport \"./interfaces/IRocketJoeFactory.sol\";\n\n/// @title Launch Event Lens\n/// @author Trader Joe\n/// @notice Helper contract to fetch launch event data\ncontract LaunchEventLens {\n    struct LaunchEventData {\n        uint256 auctionStart;\n        uint256 phaseOneDuration;\n        uint256 phaseOneNoFeeDuration;\n        uint256 phaseTwoDuration;\n        uint256 tokenIncentivesPercent;\n        uint256 floorPrice;\n        uint256 userTimelock;\n        uint256 issuerTimelock;\n        uint256 maxWithdrawPenalty;\n        uint256 rJoePerAvax;\n        uint256 tokenReserve;\n        uint256 wavaxReserve;\n        IERC20Metadata token;\n        IJoePair pair;\n        ILaunchEvent.UserInfo userInfo;\n    }\n\n    IRocketJoeFactory public rocketJoeFactory;\n\n    /// @notice Create a new instance with required parameters\n    /// @param _rocketJoeFactory Address of the RocketJoeFactory\n    constructor(address _rocketJoeFactory) {\n        rocketJoeFactory = IRocketJoeFactory(_rocketJoeFactory);\n    }\n\n    /// @notice Get all launch event datas\n    /// @return Array of all launch event datas\n    function getAllLaunchEvents()\n        external\n        view\n        returns (LaunchEventData[] memory)\n    {\n        uint256 numLaunchEvents = rocketJoeFactory.numLaunchEvents();\n        LaunchEventData[] memory launchEventDatas = new LaunchEventData[](\n            numLaunchEvents\n        );\n\n        for (uint256 i = 0; i < numLaunchEvents; i++) {\n            address launchEventAddr = rocketJoeFactory.allRJLaunchEvents(i);\n            ILaunchEvent launchEvent = ILaunchEvent(launchEventAddr);\n            launchEventDatas[i] = getLaunchEventData(launchEvent);\n        }\n\n        return launchEventDatas;\n    }\n\n    /// @notice Get all launch event datas that a given `_user` has participated in\n    /// @param _user User to lookup\n    /// @return Array of launch event datas that `_user` has participated in\n    function getUserLaunchEvents(address _user)\n        external\n        view\n        returns (LaunchEventData[] memory)\n    {\n        // Since we cannot create dynamic arrays in memory, we first have\n        // to find the number of launch events the user has participated in\n        uint256 numLaunchEvents = rocketJoeFactory.numLaunchEvents();\n        uint256 numParticipatedEvents = 0;\n\n        for (uint256 i = 0; i < numLaunchEvents; i++) {\n            address launchEventAddr = rocketJoeFactory.allRJLaunchEvents(i);\n            ILaunchEvent launchEvent = ILaunchEvent(launchEventAddr);\n            ILaunchEvent.UserInfo memory userInfo = launchEvent.getUserInfo(\n                _user\n            );\n            if (userInfo.balance > 0) {\n                numParticipatedEvents += 1;\n            }\n        }\n\n        // Then we can create a fixed size array of length `numParticipatedEvents`\n        // and simply loop through all the launch events again\n        LaunchEventData[] memory launchEventDatas = new LaunchEventData[](\n            numParticipatedEvents\n        );\n        uint256 participatedEventCounter = 0;\n\n        for (uint256 i = 0; i < numLaunchEvents; i++) {\n            address launchEventAddr = rocketJoeFactory.allRJLaunchEvents(i);\n            ILaunchEvent launchEvent = ILaunchEvent(launchEventAddr);\n            ILaunchEvent.UserInfo memory userInfo = launchEvent.getUserInfo(\n                _user\n            );\n            if (userInfo.balance > 0) {\n                launchEventDatas[\n                    participatedEventCounter\n                ] = getUserLaunchEventData(launchEvent, _user);\n                participatedEventCounter += 1;\n            }\n        }\n\n        return launchEventDatas;\n    }\n\n    /// @notice Get launch event data for a given launch event and user\n    /// @param _launchEvent Launch event to lookup\n    /// @param _user User to look up\n    /// @return Launch event data for the given `_launchEvent` and `_user`\n    function getUserLaunchEventData(ILaunchEvent _launchEvent, address _user)\n        public\n        view\n        returns (LaunchEventData memory)\n    {\n        LaunchEventData memory launchEventData = getLaunchEventData(\n            _launchEvent\n        );\n        launchEventData.userInfo = _launchEvent.getUserInfo(_user);\n        return launchEventData;\n    }\n\n    /// @notice Get launch event data for a given launch event\n    /// @param _launchEvent Launch event to lookup\n    /// @return Launch event data for the given `_launchEvent`\n    function getLaunchEventData(ILaunchEvent _launchEvent)\n        public\n        view\n        returns (LaunchEventData memory)\n    {\n        (uint256 wavaxReserve, uint256 tokenReserve) = _launchEvent\n            .getReserves();\n        return\n            LaunchEventData({\n                auctionStart: _launchEvent.auctionStart(),\n                phaseOneDuration: _launchEvent.PHASE_ONE_DURATION(),\n                phaseOneNoFeeDuration: _launchEvent.PHASE_ONE_NO_FEE_DURATION(),\n                phaseTwoDuration: _launchEvent.PHASE_TWO_DURATION(),\n                tokenIncentivesPercent: _launchEvent.tokenIncentivesPercent(),\n                floorPrice: _launchEvent.floorPrice(),\n                userTimelock: _launchEvent.userTimelock(),\n                issuerTimelock: _launchEvent.issuerTimelock(),\n                maxWithdrawPenalty: _launchEvent.maxWithdrawPenalty(),\n                rJoePerAvax: _launchEvent.rJoePerAvax(),\n                tokenReserve: tokenReserve,\n                wavaxReserve: wavaxReserve,\n                token: _launchEvent.token(),\n                pair: _launchEvent.pair(),\n                userInfo: ILaunchEvent.UserInfo({\n                    allocation: 0,\n                    balance: 0,\n                    hasWithdrawnPair: false,\n                    hasWithdrawnIncentives: false\n                })\n            });\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}