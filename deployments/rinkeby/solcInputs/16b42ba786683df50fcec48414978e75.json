{
  "language": "Solidity",
  "sources": {
    "contracts/RocketJoeFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\n\nimport \"./interfaces/IRocketJoeFactory.sol\";\nimport \"./interfaces/IJoeFactory.sol\";\nimport \"./interfaces/ILaunchEvent.sol\";\n\nimport \"./RocketJoeToken.sol\";\n\n/// @title Rocket Joe Factory\n/// @author Trader Joe\n/// @notice Factory that creates Rocket Joe events\ncontract RocketJoeFactory is IRocketJoeFactory, Ownable {\n    address public override penaltyCollector;\n    address public override eventImplementation;\n\n    address public override rJoe;\n    uint256 public override rJoePerAvax;\n    address public override wavax;\n    address public override router;\n    address public override factory;\n\n    uint256 public override PHASE_ONE_DURATION = 2 days;\n    uint256 public override PHASE_ONE_NO_FEE_DURATION = 1 days;\n    uint256 public override PHASE_TWO_DURATION = 1 days;\n\n    mapping(address => address) public override getRJLaunchEvent;\n    mapping(address => bool) public override isRJLaunchEvent;\n    address[] public override allRJLaunchEvents;\n\n    /// @notice Creates the launch event factory\n    /// @dev Uses clone factory pattern to save space\n    /// @param _eventImplementation Implementation of launch event contract\n    /// @param _rJoe rJOE token address\n    /// @param _wavax WAVAX token address\n    /// @param _penaltyCollector Address that collects all withdrawal penalties\n    /// @param _router Router used to create LP on Trader Joe AMM\n    /// @param _factory Factory used to get info of JoePairs\n    constructor(\n        address _eventImplementation,\n        address _rJoe,\n        address _wavax,\n        address _penaltyCollector,\n        address _router,\n        address _factory\n    ) {\n        require(\n            _eventImplementation != address(0) &&\n                _rJoe != address(0) &&\n                _wavax != address(0) &&\n                _penaltyCollector != address(0) &&\n                _router != address(0) &&\n                _factory != address(0),\n            \"RJFactory: Addresses can't be null address\"\n        );\n        eventImplementation = _eventImplementation;\n        rJoe = _rJoe;\n\n        (bool success, ) = address(_rJoe).call(\n            abi.encodeWithSignature(\"initialize()\")\n        );\n        require(success, \"RJFactory: failed to initialize RocketJoeToken\");\n\n        wavax = _wavax;\n        penaltyCollector = _penaltyCollector;\n        router = _router;\n        factory = _factory;\n        rJoePerAvax = 100;\n    }\n\n    /// @notice Returns the number of launch events\n    /// @return The number of launch events ever created\n    function numLaunchEvents() external view override returns (uint256) {\n        return allRJLaunchEvents.length;\n    }\n\n    /// @notice Creates a launch event contract\n    /// @param _issuer Address of the project issuing tokens for auction\n    /// @param _phaseOneStartTime Timestamp of when launch event will start\n    /// @param _token Token that will be issued through this launch event\n    /// @param _tokenAmount Amount of tokens that will be issued\n    /// @param _tokenIncentivesPercent Additional tokens that will be given as\n    /// incentive for locking up LPs during phase 3 expressed as a percentage\n    /// of the issuing tokens for sale, scaled to 1e18\n    /// @param _floorPrice Price of each token in AVAX, scaled to 1e18\n    /// @param _maxWithdrawPenalty Maximum withdrawal penalty that can be met\n    /// during phase 1\n    /// @param _fixedWithdrawPenalty Withdrawal penalty during phase 2\n    /// @param _maxAllocation Maximum number of AVAX each participant can commit\n    /// @param _userTimelock Amount of time users' LPs will be locked for\n    /// during phase 3\n    /// @param _issuerTimelock Amount of time issuer's LP will be locked for\n    /// during phase 3\n    /// @return Address of launch event contract\n    function createRJLaunchEvent(\n        address _issuer,\n        uint256 _phaseOneStartTime,\n        address _token,\n        uint256 _tokenAmount,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external override returns (address) {\n        require(\n            getRJLaunchEvent[_token] == address(0),\n            \"RJFactory: token has already been issued\"\n        );\n        require(_token != address(0), \"RJFactory: token can't be 0 address\");\n        require(_token != wavax, \"RJFactory: token can't be wavax\");\n        require(\n            _tokenAmount > 0,\n            \"RJFactory: token amount needs to be greater than 0\"\n        );\n        require(\n            IJoeFactory(factory).getPair(wavax, _token) == address(0),\n            \"RJFactory: pair already exists\"\n        );\n\n        address launchEvent = Clones.clone(eventImplementation);\n\n        // msg.sender needs to approve RocketJoeFactory\n        IERC20(_token).transferFrom(msg.sender, launchEvent, _tokenAmount);\n\n        ILaunchEvent(payable(launchEvent)).initialize(\n            _issuer,\n            _phaseOneStartTime,\n            _token,\n            _tokenIncentivesPercent,\n            _floorPrice,\n            _maxWithdrawPenalty,\n            _fixedWithdrawPenalty,\n            _maxAllocation,\n            _userTimelock,\n            _issuerTimelock\n        );\n\n        getRJLaunchEvent[_token] = launchEvent;\n        isRJLaunchEvent[launchEvent] = true;\n        allRJLaunchEvents.push(launchEvent);\n\n        _emitLaunchedEvent(_issuer, _token, _phaseOneStartTime);\n\n        return launchEvent;\n    }\n\n    /// @notice Set rJOE address\n    /// @param _rJoe New rJOE address\n    function setRJoe(address _rJoe) external override onlyOwner {\n        rJoe = _rJoe;\n        emit SetRJoe(_rJoe);\n    }\n\n    /// @notice Set address to collect withdrawal penalties\n    /// @param _penaltyCollector New penalty collector address\n    function setPenaltyCollector(address _penaltyCollector)\n        external\n        override\n        onlyOwner\n    {\n        penaltyCollector = _penaltyCollector;\n        emit SetPenaltyCollector(_penaltyCollector);\n    }\n\n    /// @notice Set JoeRouter address\n    /// @param _router New router address\n    function setRouter(address _router) external override onlyOwner {\n        router = _router;\n        emit SetRouter(_router);\n    }\n\n    /// @notice Set JoeFactory address\n    /// @param _factory New factory address\n    function setFactory(address _factory) external override onlyOwner {\n        factory = _factory;\n        emit SetFactory(_factory);\n    }\n\n    /// @notice Set amount of rJOE required to deposit 1 AVAX into launch event\n    /// @dev Configured by team between launch events to control inflation\n    function setRJoePerAvax(uint256 _rJoePerAvax) external override onlyOwner {\n        rJoePerAvax = _rJoePerAvax;\n        emit SetRJoePerAvax(_rJoePerAvax);\n    }\n\n    /// @notice Set duration of each of the three phases\n    /// @param _phaseNumber Can be only 1 or 2\n    /// @param _duration Duration of phase in seconds\n    function setPhaseDuration(uint256 _phaseNumber, uint256 _duration)\n        external\n        override\n        onlyOwner\n    {\n        if (_phaseNumber == 1) {\n            require(\n                _duration > PHASE_ONE_NO_FEE_DURATION,\n                \"RJFactory: phase one duration lower than no fee duration\"\n            );\n            PHASE_ONE_DURATION = _duration;\n        } else if (_phaseNumber == 2) {\n            PHASE_TWO_DURATION = _duration;\n        }\n    }\n\n    /// @notice Set the no fee duration of phase 1\n    /// @param _noFeeDuration Duration of no fee phase\n    function setPhaseOneNoFeeDuration(uint256 _noFeeDuration)\n        external\n        override\n        onlyOwner\n    {\n        require(\n            _noFeeDuration < PHASE_ONE_DURATION,\n            \"RJFactory: no fee duration bigger than phase one duration\"\n        );\n        PHASE_ONE_NO_FEE_DURATION = _noFeeDuration;\n    }\n\n    /// @dev This function emits an event after a new launch event has been created\n    /// It is only seperated out due to `createRJLaunchEvent` having too many local variables\n    function _emitLaunchedEvent(\n        address _issuer,\n        address _token,\n        uint256 _phaseOneStartTime\n    ) internal {\n        uint256 _phaseTwoStartTime = _phaseOneStartTime + PHASE_ONE_DURATION;\n        uint256 _phaseThreeStartTime = _phaseTwoStartTime + PHASE_TWO_DURATION;\n\n        emit RJLaunchEventCreated(\n            _issuer,\n            _token,\n            _phaseOneStartTime,\n            _phaseTwoStartTime,\n            _phaseThreeStartTime,\n            rJoe,\n            rJoePerAvax\n        );\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "contracts/interfaces/IRocketJoeFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.8.0;\n\ninterface IRocketJoeFactory {\n    event RJLaunchEventCreated(\n        address indexed issuer,\n        address indexed token,\n        uint256 phaseOneStartTime,\n        uint256 phaseTwoStartTime,\n        uint256 phaseThreeStartTime,\n        address rJoe,\n        uint256 rJoePerAvax\n    );\n    event SetRJoe(address indexed token);\n    event SetPenaltyCollector(address indexed collector);\n    event SetRouter(address indexed router);\n    event SetFactory(address indexed factory);\n    event SetRJoePerAvax(uint256 rJoePerAvax);\n\n    function eventImplementation() external view returns (address);\n\n    function penaltyCollector() external view returns (address);\n\n    function wavax() external view returns (address);\n\n    function rJoePerAvax() external view returns (uint256);\n\n    function router() external view returns (address);\n\n    function factory() external view returns (address);\n\n    function rJoe() external view returns (address);\n\n    function PHASE_ONE_DURATION() external view returns (uint256);\n\n    function PHASE_ONE_NO_FEE_DURATION() external view returns (uint256);\n\n    function PHASE_TWO_DURATION() external view returns (uint256);\n\n    function getRJLaunchEvent(address token)\n        external\n        view\n        returns (address launchEvent);\n\n    function isRJLaunchEvent(address token) external view returns (bool);\n\n    function allRJLaunchEvents(uint256) external view returns (address pair);\n\n    function numLaunchEvents() external view returns (uint256);\n\n    function createRJLaunchEvent(\n        address _issuer,\n        uint256 _phaseOneStartTime,\n        address _token,\n        uint256 _tokenAmount,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external returns (address pair);\n\n    function setPenaltyCollector(address) external;\n\n    function setRouter(address) external;\n\n    function setFactory(address) external;\n\n    function setRJoe(address) external;\n\n    function setRJoePerAvax(uint256) external;\n\n    function setPhaseDuration(uint256, uint256) external;\n\n    function setPhaseOneNoFeeDuration(uint256) external;\n}\n"
    },
    "contracts/interfaces/IJoeFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.8.0;\n\ninterface IJoeFactory {\n    event PairCreated(\n        address indexed token0,\n        address indexed token1,\n        address pair,\n        uint256\n    );\n\n    function feeTo() external view returns (address);\n\n    function feeToSetter() external view returns (address);\n\n    function migrator() external view returns (address);\n\n    function getPair(address tokenA, address tokenB)\n        external\n        view\n        returns (address pair);\n\n    function allPairs(uint256) external view returns (address pair);\n\n    function allPairsLength() external view returns (uint256);\n\n    function createPair(address tokenA, address tokenB)\n        external\n        returns (address pair);\n\n    function setFeeTo(address) external;\n\n    function setFeeToSetter(address) external;\n\n    function setMigrator(address) external;\n}\n"
    },
    "contracts/interfaces/ILaunchEvent.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface ILaunchEvent {\n    function initialize(\n        address _issuer,\n        uint256 _phaseOne,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external;\n}\n"
    },
    "contracts/RocketJoeToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./interfaces/IRocketJoeFactory.sol\";\n\n/// @title Rocket Joe Token - rJOE\n/// @author Trader Joe\n/// @notice Infinite supply, but burned to join launch event\ncontract RocketJoeToken is ERC20(\"RocketJoeToken\", \"rJOE\"), Ownable {\n    IRocketJoeFactory public rocketJoeFactory;\n\n    /// @notice Modifier which checks if message.sender is a launch event\n    modifier onlyRJLaunchEvent() {\n        require(\n            rocketJoeFactory.isRJLaunchEvent(msg.sender),\n            \"RocketJoeToken: caller is not a RJLaunchEvent\"\n        );\n        _;\n    }\n\n    /// @notice Initialise the rocketJoeFactory address\n    function initialize() external {\n        require(\n            address(rocketJoeFactory) == address(0),\n            \"RocketJoeToken: already initialized\"\n        );\n\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n    }\n\n    /// @dev Creates `_amount` token to `_to`. Must only be called by the owner (RocketJoeStaking)\n    /// @param _to The address that will receive the mint\n    /// @param _amount The amount to be minted\n    function mint(address _to, uint256 _amount) external onlyOwner {\n        _mint(_to, _amount);\n    }\n\n    /// @dev Destroys `_amount` tokens from `_from`. Callable only by a RJLaunchEvent\n    /// this doesn't need any approval in order to avoid double approval before entering each launch event\n    /// @param _from The address that will burn tokens\n    /// @param _amount The amount to be burned\n    function burnFrom(address _from, uint256 _amount)\n        external\n        onlyRJLaunchEvent\n    {\n        _burn(_from, _amount);\n    }\n\n    /// @dev Hook that is called before any transfer of tokens. This includes\n    /// minting and burning\n    /// @param _from The address that will transfer the tokens\n    /// @param _to The address that will receive the tokens\n    /// @param _amount The amount of token to send\n    function _beforeTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal virtual override {\n        require(\n            _from == address(0) || _to == address(0) || _from == owner(),\n            \"RocketJoeToken: can't send token\"\n        );\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/LaunchEvent.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"./interfaces/IJoeFactory.sol\";\nimport \"./interfaces/IJoePair.sol\";\nimport \"./interfaces/IJoeRouter02.sol\";\nimport \"./interfaces/IRocketJoeFactory.sol\";\nimport \"./interfaces/IRocketJoeToken.sol\";\nimport \"./interfaces/IWAVAX.sol\";\n\n/// @title Rocket Joe Launch Event\n/// @author Trader Joe\n/// @notice A liquidity launch contract enabling price discovery and token distribution at secondary market listing price\ncontract LaunchEvent is Ownable {\n    /// @notice The phases the launch event can be in\n    /// @dev Should these have more semantic names: Bid, Cancel, Withdraw\n    enum Phase {\n        NotStarted,\n        PhaseOne,\n        PhaseTwo,\n        PhaseThree\n    }\n\n    struct UserInfo {\n        /// @notice How much AVAX user can deposit for this launch event\n        /// @dev Can be increased by burning more rJOE, but will always be\n        /// smaller than `maxAllocation`\n        uint256 allocation;\n        /// @notice How much AVAX user has deposited for this launch event\n        uint256 balance;\n        /// @notice Whether user has withdrawn the LP\n        bool hasWithdrawnPair;\n        /// @notice Whether user has withdrawn the issuing token incentives\n        bool hasWithdrawnIncentives;\n    }\n\n    /// @notice Issuer of sale tokens\n    address public issuer;\n\n    /// @notice The start time of phase 1\n    uint256 public auctionStart;\n\n    uint256 public PHASE_ONE_DURATION;\n    uint256 public PHASE_ONE_NO_FEE_DURATION;\n    uint256 public PHASE_TWO_DURATION;\n\n    /// @dev Amount of tokens used as incentives for locking up LPs during phase 3,\n    /// in parts per 1e18 and expressed as an additional percentage to the tokens for auction.\n    /// E.g. if tokenIncentivesPercent = 5e16 (5%), and issuer sends 105 000 tokens,\n    /// then 105 000 * 1e18 / (1e18 + 5e16) = 5 000 tokens are used for incentives\n    uint256 public tokenIncentivesPercent;\n\n    /// @notice Floor price in AVAX per token (can be 0)\n    /// @dev floorPrice is scaled to 1e18\n    uint256 public floorPrice;\n\n    /// @notice Timelock duration post phase 3 when can user withdraw their LP tokens\n    uint256 public userTimelock;\n\n    /// @notice Timelock duration post phase 3 When can issuer withdraw their LP tokens\n    uint256 public issuerTimelock;\n\n    /// @notice The max withdraw penalty during phase 1, in parts per 1e18\n    /// e.g. max penalty of 50% `maxWithdrawPenalty`= 5e17\n    uint256 public maxWithdrawPenalty;\n\n    /// @notice The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// e.g. fixed penalty of 20% `fixedWithdrawPenalty = 2e17`\n    uint256 public fixedWithdrawPenalty;\n\n    IRocketJoeToken public rJoe;\n    uint256 public rJoePerAvax;\n    IWAVAX private WAVAX;\n    IERC20Metadata public token;\n\n    IJoeRouter02 private router;\n    IJoeFactory private factory;\n    IRocketJoeFactory public rocketJoeFactory;\n\n    bool private initialized;\n    bool public stopped;\n\n    uint256 public maxAllocation;\n\n    mapping(address => UserInfo) public getUserInfo;\n\n    /// @dev The address of the JoePair, set after createLiquidityPool is called\n    IJoePair public pair;\n\n    /// @dev The total amount of wavax that was sent to the router to create the initial liquidity pair.\n    /// Used to calculate the amount of LP to send based on the user's participation in the launch event\n    uint256 private wavaxAllocated;\n\n    /// @dev The exact supply of LP minted when creating the initial liquidity pair.\n    uint256 private lpSupply;\n\n    /// @dev Used to know how many issuing tokens will be sent to JoeRouter to create the initial\n    /// liquidity pair. If floor price is not met, we will send fewer issuing tokens and `tokenReserve`\n    /// will keep track of the leftover amount. It's then used to calculate the number of tokens needed\n    /// to be sent to both issuer and users (if there are leftovers and every token is sent to the pair,\n    /// tokenReserve will be equal to 0)\n    uint256 private tokenReserve;\n\n    /// @dev Keeps track of amount of token incentives that needs to be kept by contract in order to send the right\n    /// amounts to issuer and users\n    uint256 private tokenIncentivesBalance;\n    /// @dev Total incentives for users for locking their LPs for an additional period of time after the pair is created\n    uint256 private tokenIncentivesForUsers;\n    /// @dev The share refunded to the issuer. Users receive 5% of the token that were sent to the Router.\n    /// If the floor price is not met, the incentives still needs to be 5% of the value sent to the Router, so there\n    /// will be an excess of tokens returned to the issuer if he calls `withdrawIncentives()`\n    uint256 private tokenIncentiveIssuerRefund;\n\n    /// @dev wavaxReserve is the exact amount of WAVAX that needs to be kept inside the contract in order to send everyone's\n    /// WAVAX. If there is some excess (because someone sent token directly to the contract), the\n    /// penaltyCollector can collect the excess using `skim()`\n    uint256 private wavaxReserve;\n\n    event IssuingTokenDeposited(address indexed token, uint256 amount);\n\n    event UserParticipated(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 rJoeAmount\n    );\n\n    event UserWithdrawn(address indexed user, uint256 avaxAmount);\n\n    event LiquidityPoolCreated(\n        address indexed pair,\n        address indexed token0,\n        address indexed token1,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    event UserLiquidityWithdrawn(\n        address indexed user,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event IssuerLiquidityWithdrawn(\n        address indexed issuer,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event Stopped();\n\n    event AvaxEmergencyWithdraw(address indexed user, uint256 amount);\n\n    event TokenEmergencyWithdraw(address indexed user, uint256 amount);\n\n    /// @notice Receive AVAX from the WAVAX contract\n    /// @dev Needed for withdrawing from WAVAX contract\n    receive() external payable {\n        require(\n            msg.sender == address(WAVAX),\n            \"LaunchEvent: you can't send AVAX directly to this contract\"\n        );\n    }\n\n    /// @notice Modifier which ensures contract is in a defined phase\n    modifier atPhase(Phase _phase) {\n        _atPhase(_phase);\n        _;\n    }\n\n    /// @notice Modifier which ensures the caller's timelock to withdraw has elapsed\n    modifier timelockElapsed() {\n        uint256 phase3Start = auctionStart +\n            PHASE_ONE_DURATION +\n            PHASE_TWO_DURATION;\n        require(\n            block.timestamp > phase3Start + userTimelock,\n            \"LaunchEvent: can't withdraw before user's timelock\"\n        );\n        if (msg.sender == issuer) {\n            require(\n                block.timestamp > phase3Start + issuerTimelock,\n                \"LaunchEvent: can't withdraw before issuer's timelock\"\n            );\n        }\n        _;\n    }\n\n    /// @notice Ensures launch event is stopped/running\n    modifier isStopped(bool _stopped) {\n        if (_stopped) {\n            require(stopped, \"LaunchEvent: is still running\");\n        } else {\n            require(!stopped, \"LaunchEvent: stopped\");\n        }\n        _;\n    }\n\n    /// @notice Initialise the launch event with needed paramaters\n    /// @param _issuer Address of the token issuer\n    /// @param _auctionStart The start time of the auction\n    /// @param _token The contract address of auctioned token\n    /// @param _tokenIncentivesPercent The token incentives percent, in part per 1e18, e.g 5e16 is 5% of incentives\n    /// @param _floorPrice The minimum price the token is sold at\n    /// @param _maxWithdrawPenalty The max withdraw penalty during phase 1, in parts per 1e18\n    /// @param _fixedWithdrawPenalty The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// @param _maxAllocation The maximum amount of AVAX depositable\n    /// @param _userTimelock The time a user must wait after auction ends to withdraw liquidity\n    /// @param _issuerTimelock The time the issuer must wait after auction ends to withdraw liquidity\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(!initialized, \"LaunchEvent: already initialized\");\n\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        PHASE_ONE_DURATION = rocketJoeFactory.PHASE_ONE_DURATION();\n        PHASE_ONE_NO_FEE_DURATION = rocketJoeFactory.PHASE_ONE_NO_FEE_DURATION();\n        PHASE_TWO_DURATION = rocketJoeFactory.PHASE_TWO_DURATION();\n\n        token = IERC20Metadata(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n        initialized = true;\n    }\n\n    /// @notice The current phase the auction is in\n    function currentPhase() public view returns (Phase) {\n        if (block.timestamp < auctionStart || auctionStart == 0) {\n            return Phase.NotStarted;\n        } else if (block.timestamp < auctionStart + PHASE_ONE_DURATION) {\n            return Phase.PhaseOne;\n        } else if (\n            block.timestamp <\n            auctionStart + PHASE_ONE_DURATION + PHASE_TWO_DURATION\n        ) {\n            return Phase.PhaseTwo;\n        }\n        return Phase.PhaseThree;\n    }\n\n    /// @notice Deposits AVAX and burns rJoe\n    /// @dev Checks are done in the `_depositWAVAX` function\n    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Burn tokens and update allocation.\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        wavaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        WAVAX.deposit{value: msg.value}();\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n\n    /// @notice Withdraw AVAX, only permitted during phase 1 and 2\n    /// @param _amount The amount of AVAX to withdraw\n    function withdrawAVAX(uint256 _amount) public isStopped(false) {\n        Phase _currentPhase = currentPhase();\n        require(\n            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,\n            \"LaunchEvent: unable to withdraw\"\n        );\n        require(_amount > 0, \"LaunchEvent: invalid withdraw amount\");\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            user.balance >= _amount,\n            \"LaunchEvent: withdrawn amount exceeds balance\"\n        );\n        user.balance -= _amount;\n\n        uint256 feeAmount = (_amount * getPenalty()) / 1e18;\n        uint256 amountMinusFee = _amount - feeAmount;\n\n        wavaxReserve -= _amount;\n\n        WAVAX.withdraw(_amount);\n        _safeTransferAVAX(msg.sender, amountMinusFee);\n        if (feeAmount > 0) {\n            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);\n        }\n    }\n\n    /// @notice Create the JoePair\n    /// @dev Can only be called once after phase 3 has started\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        require(\n            factory.getPair(wavaxAddress, tokenAddress) == address(0),\n            \"LaunchEvent: pair already created\"\n        );\n        require(wavaxReserve > 0, \"LaunchEvent: no wavax balance\");\n\n        uint256 tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (wavaxReserve * 1e18) / tokenAllocated) {\n            tokenAllocated = (wavaxReserve * 10**token.decimals()) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        WAVAX.approve(address(router), wavaxReserve);\n        token.approve(address(router), tokenAllocated);\n\n        /// We can't trust the output cause of reflect tokens\n        (, , lpSupply) = router.addLiquidity(\n            wavaxAddress, // tokenA\n            tokenAddress, // tokenB\n            wavaxReserve, // amountADesired\n            tokenAllocated, // amountBDesired\n            wavaxReserve, // amountAMin\n            tokenAllocated, // amountBMin\n            address(this), // to\n            block.timestamp // deadline\n        );\n\n        pair = IJoePair(factory.getPair(tokenAddress, wavaxAddress));\n        wavaxAllocated = wavaxReserve;\n        wavaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            wavaxAllocated\n        );\n    }\n\n    /// @notice Withdraw liquidity pool tokens\n    function withdrawLiquidity()\n        external\n        isStopped(false)\n        atPhase(Phase.PhaseThree)\n        timelockElapsed\n    {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            !user.hasWithdrawnPair,\n            \"LaunchEvent: liquidity already withdrawn\"\n        );\n\n        uint256 balance = pairBalance(msg.sender);\n        user.hasWithdrawnPair = true;\n\n        if (msg.sender == issuer) {\n            balance = lpSupply / 2;\n\n            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);\n\n            if (tokenReserve > 0) {\n                uint256 amount = tokenReserve;\n                tokenReserve = 0;\n                token.transfer(msg.sender, amount);\n            }\n        } else {\n            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n        }\n\n        pair.transfer(msg.sender, balance);\n    }\n\n    /// @notice Withdraw incentives tokens\n    function withdrawIncentives() external isStopped(false) {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            !user.hasWithdrawnIncentives,\n            \"LaunchEvent: incentives already withdrawn\"\n        );\n\n        user.hasWithdrawnIncentives = true;\n        uint256 amount;\n\n        if (msg.sender == issuer) {\n            amount = tokenIncentiveIssuerRefund;\n        } else {\n            amount = (user.balance * tokenIncentivesForUsers) / wavaxAllocated;\n        }\n\n        require(amount > 0, \"LaunchEvent: caller has no incentive to claim\");\n\n        tokenIncentivesBalance -= amount;\n\n        token.transfer(msg.sender, amount);\n    }\n\n    /// @notice Withdraw AVAX if launch has been cancelled\n    function emergencyWithdraw() external isStopped(true) {\n        if (msg.sender != issuer) {\n            UserInfo storage user = getUserInfo[msg.sender];\n            require(\n                user.balance > 0,\n                \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n            );\n\n            uint256 balance = user.balance;\n            user.balance = 0;\n            wavaxReserve -= balance;\n            WAVAX.withdraw(balance);\n\n            _safeTransferAVAX(msg.sender, balance);\n\n            emit AvaxEmergencyWithdraw(msg.sender, balance);\n        } else {\n            uint256 balance = tokenReserve + tokenIncentivesBalance;\n            tokenReserve = 0;\n            tokenIncentivesBalance = 0;\n            token.transfer(issuer, balance);\n            emit TokenEmergencyWithdraw(msg.sender, balance);\n        }\n    }\n\n    /// @notice Stops the launch event and allows participants withdraw deposits\n    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n    /// @notice Force balances to match tokens that were deposited, but not sent directly to the contract.\n    /// Any excess tokens are sent to the penaltyCollector\n    function skim() external {\n        address penaltyCollector = rocketJoeFactory.penaltyCollector();\n\n        uint256 excessToken = token.balanceOf(address(this)) -\n            tokenReserve -\n            tokenIncentivesBalance;\n        if (excessToken > 0) {\n            token.transfer(penaltyCollector, excessToken);\n        }\n\n        uint256 excessWavax = WAVAX.balanceOf(address(this)) - wavaxReserve;\n        if (excessWavax > 0) {\n            WAVAX.transfer(penaltyCollector, excessWavax);\n        }\n\n        uint256 excessAvax = address(this).balance;\n        if (excessAvax > 0) _safeTransferAVAX(penaltyCollector, excessAvax);\n    }\n\n    /// @notice Returns the current penalty for early withdrawal\n    /// @return The penalty to apply to a withdrawal amount\n    function getPenalty() public view returns (uint256) {\n        uint256 timeElapsed = block.timestamp - auctionStart;\n        if (timeElapsed < PHASE_ONE_NO_FEE_DURATION) {\n            return 0;\n        } else if (timeElapsed < PHASE_ONE_DURATION) {\n            return\n                ((timeElapsed - PHASE_ONE_NO_FEE_DURATION) *\n                    maxWithdrawPenalty) /\n                uint256(PHASE_ONE_DURATION - PHASE_ONE_NO_FEE_DURATION);\n        }\n        return fixedWithdrawPenalty;\n    }\n\n    /// @notice Returns the current balance of the pool\n    /// @return The balances of WAVAX and issued token held by the launch contract\n    function getReserves() external view returns (uint256, uint256) {\n        return (wavaxReserve, tokenReserve + tokenIncentivesBalance);\n    }\n\n    /// @notice Get the rJOE amount needed to deposit AVAX\n    /// @param _avaxAmount The amount of AVAX to deposit\n    /// @return The amount of rJOE needed\n    function getRJoeAmount(uint256 _avaxAmount) public view returns (uint256) {\n        return _avaxAmount * rJoePerAvax;\n    }\n\n    /// @notice The total amount of liquidity pool tokens the user can withdraw\n    /// @param _user The address of the user to check\n    function pairBalance(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n        if (wavaxAllocated == 0 || user.hasWithdrawnPair) {\n            return 0;\n        }\n        return (user.balance * lpSupply) / wavaxAllocated / 2;\n    }\n\n    /// @dev Bytecode size optimization for the `atPhase` modifier.\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _atPhase(Phase _phase) internal view {\n        if (_phase == Phase.NotStarted) {\n            require(\n                currentPhase() == Phase.NotStarted,\n                \"LaunchEvent: not in not started\"\n            );\n        } else if (_phase == Phase.PhaseOne) {\n            require(\n                currentPhase() == Phase.PhaseOne,\n                \"LaunchEvent: not in phase one\"\n            );\n        } else if (_phase == Phase.PhaseTwo) {\n            require(\n                currentPhase() == Phase.PhaseTwo,\n                \"LaunchEvent: not in phase two\"\n            );\n        } else if (_phase == Phase.PhaseThree) {\n            require(\n                currentPhase() == Phase.PhaseThree,\n                \"LaunchEvent: not in phase three\"\n            );\n        } else {\n            revert(\"LaunchEvent: unknown state\");\n        }\n    }\n\n    /// @notice Send AVAX\n    /// @param _to The receiving address\n    /// @param _value The amount of AVAX to send\n    /// @dev Will revert on failure\n    function _safeTransferAVAX(address _to, uint256 _value) internal {\n        (bool success, ) = _to.call{value: _value}(new bytes(0));\n        require(success, \"LaunchEvent: avax transfer failed\");\n    }\n}\n"
    },
    "contracts/interfaces/IJoePair.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.8.0;\n\ninterface IJoePair {\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external pure returns (string memory);\n\n    function symbol() external pure returns (string memory);\n\n    function decimals() external pure returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    function nonces(address owner) external view returns (uint256);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n    event Burn(\n        address indexed sender,\n        uint256 amount0,\n        uint256 amount1,\n        address indexed to\n    );\n    event Swap(\n        address indexed sender,\n        uint256 amount0In,\n        uint256 amount1In,\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n    function factory() external view returns (address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 reserve0,\n            uint112 reserve1,\n            uint32 blockTimestampLast\n        );\n\n    function price0CumulativeLast() external view returns (uint256);\n\n    function price1CumulativeLast() external view returns (uint256);\n\n    function kLast() external view returns (uint256);\n\n    function mint(address to) external returns (uint256 liquidity);\n\n    function burn(address to)\n        external\n        returns (uint256 amount0, uint256 amount1);\n\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function skim(address to) external;\n\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "contracts/interfaces/IJoeRouter02.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.8.0;\n\nimport \"./IJoeRouter01.sol\";\n\ninterface IJoeRouter02 is IJoeRouter01 {\n    function removeLiquidityAVAXSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountAVAXMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountAVAX);\n\n    function removeLiquidityAVAXWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountAVAXMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountAVAX);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n\n    function swapExactAVAXForTokensSupportingFeeOnTransferTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable;\n\n    function swapExactTokensForAVAXSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n}\n"
    },
    "contracts/interfaces/IRocketJoeToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IRocketJoeToken {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Destroys `amount` tokens from `from`.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burnFrom(address from, uint256 amount) external;\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n"
    },
    "contracts/interfaces/IWAVAX.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.8.0;\n\ninterface IWAVAX {\n    function deposit() external payable;\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function withdraw(uint256) external;\n\n    function balanceOf(address account) external returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n}\n"
    },
    "contracts/interfaces/IJoeRouter01.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.8.0;\n\ninterface IJoeRouter01 {\n    function factory() external pure returns (address);\n\n    function WAVAX() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        );\n\n    function addLiquidityAVAX(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountAVAXMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (\n            uint256 amountToken,\n            uint256 amountAVAX,\n            uint256 liquidity\n        );\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityAVAX(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountAVAXMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountToken, uint256 amountAVAX);\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityAVAXWithPermit(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountAVAXMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountToken, uint256 amountAVAX);\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactAVAXForTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function swapTokensForExactAVAX(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactTokensForAVAX(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapAVAXForExactTokens(\n        uint256 amountOut,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) external pure returns (uint256 amountB);\n\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountOut);\n\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountIn);\n\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\n        external\n        view\n        returns (uint256[] memory amounts);\n\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\n        external\n        view\n        returns (uint256[] memory amounts);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}